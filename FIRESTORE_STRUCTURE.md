# Firestore Data Structure

This document describes the Cloud Firestore database schema used in the "Chat with LLM" application.

---

## Overview

The database uses a **user-centric hierarchical structure** where all data is nested under the user's unique ID. This design enables:

- **Data isolation**: Each user can only access their own data
- **Simple security rules**: One rule covers all user data
- **Efficient queries**: All user data is co-located

---

## Collection Hierarchy

```
firestore/
└── users/                          # Root collection
    └── {userId}/                   # Document: User (auto-generated UID)
        ├── profile/                # Subcollection: User profile
        │   └── info                # Document: Profile data
        │
        └── chats/                  # Subcollection: User's chats
            └── {chatId}/           # Document: Individual chat
                └── messages/       # Subcollection: Chat messages
                    └── {messageId} # Document: Individual message
```

---

## Document Schemas

### User Document
**Path**: `users/{userId}`

The user document itself is not used directly. It serves as a container for subcollections.

| Field | Type | Description |
|-------|------|-------------|
| *(none)* | - | Container document only |

---

### Profile Document
**Path**: `users/{userId}/profile/info`

Stores user metadata. Created on first sign-in.

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `createdAt` | Timestamp | Yes | When the user first signed in |
| `lastActive` | Timestamp | Yes | Last activity timestamp (updated on each session) |

**Example:**
```json
{
  "createdAt": "2026-01-27T10:30:00.000Z",
  "lastActive": "2026-01-27T15:45:22.000Z"
}
```

---

### Chat Document
**Path**: `users/{userId}/chats/{chatId}`

Represents a conversation thread. A user can have multiple chats.

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `title` | String | Yes | Chat title (generated from first message or "New Chat") |
| `createdAt` | Timestamp | Yes | When the chat was created |
| `updatedAt` | Timestamp | Yes | Last message timestamp (used for sorting) |
| `messageCount` | Number | Yes | Total number of messages in this chat |

**Example:**
```json
{
  "title": "Explain quantum computing...",
  "createdAt": "2026-01-27T10:35:00.000Z",
  "updatedAt": "2026-01-27T10:42:15.000Z",
  "messageCount": 8
}
```

---

### Message Document
**Path**: `users/{userId}/chats/{chatId}/messages/{messageId}`

Individual message within a chat.

#### Message ID Format
Message IDs use a custom sortable format: `YYYYMMDDHHMMSS-XX`

| Part | Description | Example |
|------|-------------|---------|
| `YYYYMMDDHHMMSS` | Timestamp | `20260127103512` |
| `XX` | 2 random letters | `AB` |

**Full Example**: `20260127103512-AB`

This format allows:
- Sorting messages chronologically by ID
- Avoiding ID collisions with random suffix

The model name is stored inside the message document as the `modelId` field.

#### Message Fields

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `role` | String | Yes | Message sender: `"user"` or `"assistant"` |
| `content` | String | Yes | The message text content |
| `modelId` | String | Yes | Full LLM model ID used (e.g., `"Qwen3-0.6B-q4f16_1-MLC"`) |
| `timestamp` | Timestamp | Yes | When the message was created |
| `feedback` | String/null | No | User feedback: `"up"`, `"down"`, or `null` |

**Role Values:**
- `"user"` - Message sent by the human user
- `"assistant"` - Response generated by the AI

**Feedback Values:**
- `null` - No feedback given (default)
- `"up"` - User clicked thumbs up (good response)
- `"down"` - User clicked thumbs down (poor response)

**Example User Message:**
```json
{
  "role": "user",
  "content": "What is the capital of France?",
  "modelId": "Qwen3-0.6B-q4f16_1-MLC",
  "timestamp": "2026-01-27T10:35:12.000Z",
  "feedback": null
}
```

**Example Assistant Message with Feedback:**
```json
{
  "role": "assistant",
  "content": "The capital of France is Paris. It's the largest city in France and serves as the country's political, economic, and cultural center.",
  "modelId": "Qwen3-0.6B-q4f16_1-MLC",
  "timestamp": "2026-01-27T10:35:18.000Z",
  "feedback": "up"
}
```

---

## Security Rules

Located in `firestore.rules`:

```javascript
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    // Users can only read and write their own data
    match /users/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;

      // User profile
      match /profile/{document=**} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }

      // User's chats
      match /chats/{chatId} {
        allow read, write: if request.auth != null && request.auth.uid == userId;

        // Messages within a chat
        match /messages/{messageId} {
          allow read, write: if request.auth != null && request.auth.uid == userId;
        }
      }
    }

    // Deny all other access
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
```

### Rule Explanation

| Rule | Meaning |
|------|---------|
| `request.auth != null` | User must be authenticated |
| `request.auth.uid == userId` | User can only access documents under their own UID |
| `allow read, write: if false` | Default deny for everything else |

---

## Query Patterns

### Get All Chats (sorted by recent)
```javascript
const chatsRef = collection(db, 'users', userId, 'chats');
const q = query(chatsRef, orderBy('updatedAt', 'desc'), limit(50));
```

### Get Messages for a Chat (chronological)
```javascript
const messagesRef = collection(db, 'users', userId, 'chats', chatId, 'messages');
const q = query(messagesRef, orderBy('timestamp', 'asc'), limit(100));
```

**Note**: Messages can also be sorted by document ID since IDs start with `YYYYMMDDHHMMSS` timestamp.

### Update Message Feedback
```javascript
const messageRef = doc(db, 'users', userId, 'chats', chatId, 'messages', messageId);
await updateDoc(messageRef, { feedback: 'up' }); // or 'down' or null
```

### Real-time Message Subscription
```javascript
const messagesRef = collection(db, 'users', userId, 'chats', chatId, 'messages');
const q = query(messagesRef, orderBy('timestamp', 'asc'));

const unsubscribe = onSnapshot(q, (snapshot) => {
  const messages = snapshot.docs.map(doc => ({
    id: doc.id,
    ...doc.data()
  }));
  // Update UI with messages
});
```

### Delete Chat with All Messages
```javascript
// Uses batch write to delete atomically
const batch = writeBatch(db);

// Delete all messages
const messagesSnap = await getDocs(messagesRef);
messagesSnap.forEach((doc) => {
  batch.delete(doc.ref);
});

// Delete chat document
batch.delete(chatRef);

await batch.commit();
```

---

## Indexes

Firestore automatically creates indexes for single-field queries. The following composite indexes may be needed:

| Collection | Fields | Order |
|------------|--------|-------|
| `chats` | `updatedAt` | Descending |
| `messages` | `timestamp` | Ascending |

These are typically auto-created when first running the queries.

---

## Data Flow

```
┌─────────────────┐     ┌──────────────────┐     ┌─────────────────┐
│  User sends     │────▶│  Save to         │────▶│  Update chat    │
│  message        │     │  messages/       │     │  updatedAt      │
└─────────────────┘     └──────────────────┘     └─────────────────┘
                                                          │
                                                          ▼
┌─────────────────┐     ┌──────────────────┐     ┌─────────────────┐
│  Display in     │◀────│  Real-time       │◀────│  Firestore      │
│  chat UI        │     │  listener        │     │  triggers       │
└─────────────────┘     └──────────────────┘     └─────────────────┘
```

---

## Storage Estimates

| Item | Approximate Size |
|------|-----------------|
| Profile document | ~100 bytes |
| Chat document | ~200 bytes |
| Message document | ~500 bytes (average) |
| 100 messages | ~50 KB |
| 1000 messages | ~500 KB |

**Free tier limit**: 1 GB total storage

---

## Related Files

| File | Purpose |
|------|---------|
| `public/db.js` | All Firestore CRUD operations |
| `public/firebase-config.js` | Firebase initialization |
| `firestore.rules` | Security rules |

---

## Best Practices Used

1. **User-scoped data**: All data under `users/{userId}` for isolation
2. **Subcollections for lists**: Messages as subcollection, not array field
3. **Denormalization**: `messageCount` stored on chat for quick display
4. **Server timestamps**: Using `serverTimestamp()` for consistency
5. **Batch operations**: Atomic deletes for chat + messages
6. **Real-time listeners**: For live updates without polling

---

*Last updated: January 2026*
